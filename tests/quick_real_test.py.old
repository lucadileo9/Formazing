"""
Quick Real Test - Test interattivo per componenti reali usando fixture pytest

SCOPO:
- Test veloce di tutti i componenti reali
- Interattivo: chiede cosa testare  
- Perfetto per debug e sviluppo
- Usa fixture centralizzate da conftest.py

USAGE:
    pytest tests/quick_real_test.py::test_quick_interactive -s
    oppure
    python -m pytest tests/quick_real_test.py::test_quick_interactive -s
    
FEATURES:
- Test formattazione senza invio (sempre sicuro)
- Invio notifiche formazione reali (opzionale, chiede conferma)
- Invio notifiche feedback reali (opzionale, chiede conferma)
- Test comandi bot interattivi (opzionale)  
- Diagnostica completa sistema
- Usa fixture pytest per configurazione automatica
"""

import asyncio
import pytest
from datetime import datetime


class QuickTestRunner:
    """Runner per test rapidi interattivi usando fixture pytest."""
    
    def __init__(self, telegram_service, notion_service, sample_data):
        """
        Inizializza runner con servizi dalle fixture.
        
        Args:
            telegram_service: TelegramService configurato (da fixture)
            notion_service: MockNotionService (da fixture)  
            sample_data: Dati di esempio (da fixture)
        """
        self.service = telegram_service
        self.mock_notion = notion_service
        self.sample_data = sample_data
        
        print("ğŸ”§ Setup sistema di test...")
        print(f"âœ… Sistema configurato con {len(self.service.groups)} gruppi di test")
        print("âœ… Mock Notion service configurato dalle fixture")
    
    async def test_1_formatting_only(self):
        """Test 1: Solo formattazione (sicuro, no invio)."""
        print("\n" + "="*50)
        print("ğŸ¨ TEST 1: FORMATTAZIONE (no invio)")
        print("="*50)
        
        training_data = self.sample_data
        print(f"ğŸ“Š Dati test: {training_data['Nome']} - {training_data['Area']}")
        
        try:
            # Test formattazione training
            main_msg = self.service.formatter.format_training_message(training_data, 'main_group')
            area_msg = self.service.formatter.format_training_message(training_data, 'area_group')
            
            # Test formattazione feedback
            feedback_msg = self.service.formatter.format_feedback_message(
                training_data, 
                'https://forms.office.com/test-feedback',
                'message'
            )
            
            print(f"\nğŸ“„ TRAINING MAIN MESSAGE (primi 150 char):")
            print(f"ğŸ“ {main_msg[:150]}...")
            
            print(f"\nğŸ“„ TRAINING AREA MESSAGE (primi 150 char):")
            print(f"ğŸ“ {area_msg[:150]}...")
            
            print(f"\nğŸ“„ FEEDBACK MESSAGE (primi 150 char):")
            print(f"ğŸ“ {feedback_msg[:150]}...")
            
            # Verifica marker [TEST]
            messages = [main_msg, area_msg, feedback_msg]
            all_have_test = all('[TEST]' in msg for msg in messages)
            
            if all_have_test:
                print(f"\nâœ… Formattazione OK - Tutti i messaggi hanno marker [TEST]")
                return True
            else:
                print(f"\nâš ï¸ Attenzione: Marker [TEST] mancante in alcuni messaggi")
                return False
                
        except Exception as e:
            print(f"\nâŒ Errore formattazione: {e}")
            return False
    
    async def test_2_send_real_notification(self):
        """Test 2: Invio notifica reale (opzionale)."""
        print("\n" + "="*50)
        print("ğŸ“¤ TEST 2: INVIO NOTIFICA REALE")
        print("="*50)
        
        print("âš ï¸  ATTENZIONE: Questo test invierÃ  messaggi REALI sui gruppi Telegram!")
        print("ğŸ“± I messaggi saranno inviati sui gruppi configurati in test_telegram_groups.json")
        print("ğŸ” I messaggi saranno marcati [TEST] per identificarli")
        
        confirm = input("\nâ“ Vuoi continuare con l'invio reale? (y/N): ").strip().lower()
        
        if confirm not in ['y', 'yes', 's', 'si']:
            print("â­ï¸ Invio notifica saltato")
            return True
        
        # Usa dati dalle fixture con modifiche per invio reale
        training_data = self.sample_data.copy()
        training_data['Nome'] = f'Real Test Course {datetime.now().strftime("%H:%M")}'
        training_data['Codice'] = f'REAL{datetime.now().strftime("%H%M")}'
        training_data['Descrizione'] = 'Test reale invio notifica'
        training_data['Docente'] = 'Real Test Bot'
        
        print(f"\nğŸ“¤ Invio notifica per: {training_data['Nome']}")
        print(f"ğŸ¯ Area target: {training_data['Area']}")
        
        try:
            results = await self.service.send_training_notification(training_data)
            
            successful = sum(1 for success in results.values() if success)
            total = len(results)
            
            print(f"\nâœ… Notifica inviata a {successful}/{total} gruppi")
            print(f"ğŸ“‹ Risultati dettagli:")
            for group, success in results.items():
                status = "âœ…" if success else "âŒ"
                print(f"   {status} {group}")
            
            print(f"\nğŸ” Controlla i gruppi Telegram per vedere i messaggi!")
            return successful > 0
            
        except Exception as e:
            print(f"\nâŒ Errore invio: {e}")
            return False
    
    async def test_3_bot_commands(self):
        """Test 3: Comandi bot interattivi."""
        print("\n" + "="*50)
        print("ğŸ¤– TEST 3: COMANDI BOT INTERATTIVI")
        print("="*50)
        
        # Info dati mock
        mock_info = self.mock_notion.get_current_test_info()
        print(f"ğŸ“Š Mock Notion configurato:")
        print(f"   ğŸ“… Data base: {mock_info['base_date']}")
        print(f"   ğŸ“‹ Formazioni oggi: {mock_info['today_formazioni']}")
        print(f"   ğŸ“‹ Formazioni domani: {mock_info['tomorrow_formazioni']}")
        print(f"   ğŸ“‹ Formazioni settimana: {mock_info['week_formazioni']}")
        
        print(f"\nâš ï¸  Questo test avvierÃ  il bot per 30 secondi")
        print(f"ğŸ“± Potrai testare manualmente i comandi su Telegram")
        
        test_commands = input(f"\nâ“ Vuoi testare i comandi bot? (y/N): ").strip().lower()
        
        if test_commands not in ['y', 'yes', 's', 'si']:
            print("â­ï¸ Test comandi saltato")
            return True
        
        print(f"\nğŸš€ Avvio bot per test comandi...")
        print(f"ğŸ’¡ Comandi disponibili:")
        print(f"   /oggi - Mostra {mock_info['today_formazioni']} formazioni di oggi")
        print(f"   /domani - Mostra {mock_info['tomorrow_formazioni']} formazione di domani")
        print(f"   /settimana - Mostra tutte le formazioni della settimana")
        print(f"   /help - Guida comandi")
        print(f"\nâ° Bot attivo per 30 secondi - CTRL+C per fermare prima")
        
        try:
            await self.service.start_bot()
            
            # Countdown visivo
            for i in range(30, 0, -5):
                print(f"â° Bot attivo - {i} secondi rimanenti...")
                await asyncio.sleep(5)
            
        except KeyboardInterrupt:
            print(f"\nâŒ¨ï¸ Test interrotto dall'utente")
        except Exception as e:
            print(f"\nâŒ Errore bot: {e}")
            return False
        finally:
            await self.service.stop_bot()
            print(f"âœ… Bot fermato")
        
        return True
    
    async def test_4_mock_data_diagnostic(self):
        """Test 4: Diagnostica dati mock."""
        print("\n" + "="*50)
        print("ğŸ” TEST 4: DIAGNOSTICA DATI MOCK")
        print("="*50)
        
        try:
            # Test recupero dati
            formazioni_cal = await self.mock_notion.get_formazioni_by_status('Calendarizzata')
            formazioni_comp = await self.mock_notion.get_formazioni_by_status('Completata')
            
            print(f"ğŸ“Š MOCK NOTION SERVICE:")
            print(f"   ğŸ“‹ Formazioni calendarizzate: {len(formazioni_cal)}")
            print(f"   ğŸ“‹ Formazioni completate: {len(formazioni_comp)}")
            
            # Test parsing date dal primo elemento
            if formazioni_cal:
                sample = formazioni_cal[0]
                commands = self.service.commands
                
                data_estratta = commands._extract_date_from_formazione(sample)
                ora_estratta = commands._extract_time_from_formazione(sample)
                giorno = commands._get_day_name(data_estratta) if data_estratta else "N/A"
                
                print(f"\nğŸ”§ TEST PARSING (campione: {sample['Nome']}):")
                print(f"   ğŸ“… Data originale: {sample['Data/Ora']}")
                print(f"   ğŸ“… Data estratta: {data_estratta}")
                print(f"   ğŸ• Ora estratta: {ora_estratta}")
                print(f"   ğŸ“† Giorno: {giorno}")
            
            # Test filtro per data
            today = datetime.now().date()
            formazioni_oggi = await self.service.commands._get_formazioni_by_date(today)
            
            print(f"\nğŸ“… FILTRO DATE (oggi {today}):")
            print(f"   ğŸ“‹ Formazioni trovate: {len(formazioni_oggi)}")
            for f in formazioni_oggi:
                print(f"      - {f['Nome']} ({f['Area']}) - {f['Data/Ora']}")
            
            return True
            
        except Exception as e:
            print(f"\nâŒ Errore diagnostica: {e}")
            return False
    
    async def test_5_send_feedback_notification(self):
        """Test 5: Invio notifica feedback reale (opzionale)."""
        print("\n" + "="*50)
        print("ğŸ“‹ TEST 5: INVIO FEEDBACK REALE")
        print("="*50)
        
        print("âš ï¸  ATTENZIONE: Questo test invierÃ  notifiche di FEEDBACK REALI!")
        print("ğŸ“± Le notifiche saranno inviate sui gruppi configurati")
        print("ğŸ” I messaggi saranno marcati [TEST] per identificarli")
        
        confirm = input("\nâ“ Vuoi continuare con l'invio feedback? (y/N): ").strip().lower()
        
        if confirm not in ['y', 'yes', 's', 'si']:
            print("â­ï¸ Invio feedback saltato")
            return True
        
        # Usa dati dalle fixture modificati per feedback
        feedback_data = self.sample_data.copy()
        feedback_data['Nome'] = f'Feedback Test Course {datetime.now().strftime("%H:%M")}'
        feedback_data['Codice'] = f'FB{datetime.now().strftime("%H%M")}'
        feedback_data['Stato/Fase'] = 'Completata'  # Necessario per feedback
        feedback_data['Descrizione'] = 'Test reale invio feedback'
        
        # URL feedback di test
        feedback_url = 'https://forms.office.com/test-feedback-form'
        
        print(f"\nğŸ“‹ Invio feedback per: {feedback_data['Nome']}")
        print(f"ğŸ¯ Area target: {feedback_data['Area']}")
        print(f"ğŸ”— URL feedback: {feedback_url}")
        
        try:
            results = await self.service.send_feedback_notification(feedback_data, feedback_url)
            
            successful = sum(1 for success in results.values() if success)
            total = len(results)
            
            print(f"\nâœ… Feedback inviato a {successful}/{total} gruppi")
            print(f"ğŸ“‹ Risultati dettagli:")
            for group, success in results.items():
                status = "âœ…" if success else "âŒ"
                print(f"   {status} {group}")
            
            print(f"\nğŸ” Controlla i gruppi Telegram per vedere i messaggi feedback!")
            return successful > 0
            
        except Exception as e:
            print(f"\nâŒ Errore invio feedback: {e}")
            return False
    
    async def run_all_tests(self):
        """Esegue tutti i test in sequenza."""
        print("ğŸ§ª QUICK REAL TEST - Formazing Bot")
        print("="*50)
        print("Questo script testa tutti i componenti reali del bot")
        print("Solo NotionService Ã¨ mock - tutto il resto Ã¨ reale!")
        print("Usando fixture pytest per configurazione automatica!")
        print("="*50)
        
        results = []
        
        # Test 1: Formattazione (sempre sicuro)
        results.append(await self.test_1_formatting_only())
        
        # Test 2: Invio notifica formazione (opzionale)
        results.append(await self.test_2_send_real_notification())
        
        # Test 3: Comandi bot (opzionale)
        results.append(await self.test_3_bot_commands())
        
        # Test 4: Diagnostica
        results.append(await self.test_4_mock_data_diagnostic())
        
        # Test 5: Invio feedback (opzionale) - NUOVO!
        results.append(await self.test_5_send_feedback_notification())
        
        # Riassunto finale
        print("\n" + "="*50)
        print("ğŸ“Š RIASSUNTO TEST")
        print("="*50)
        
        test_names = [
            "ğŸ¨ Formattazione messaggi",
            "ğŸ“¤ Invio notifica formazione", 
            "ğŸ¤– Comandi bot interattivi",
            "ğŸ” Diagnostica dati mock",
            "ğŸ“‹ Invio notifica feedback"
        ]
        
        successful = 0
        for i, (name, result) in enumerate(zip(test_names, results)):
            status = "âœ… PASS" if result else "âŒ FAIL"
            print(f"{status} {name}")
            if result:
                successful += 1
        
        print(f"\nğŸ¯ RISULTATO FINALE: {successful}/{len(results)} test superati")
        
        if successful == len(results):
            print("ğŸ‰ Tutti i test completati con successo!")
            print("ğŸš€ Il sistema Ã¨ pronto per l'uso!")
        else:
            print("âš ï¸ Alcuni test hanno fallito - Controlla i log sopra")


@pytest.mark.asyncio
@pytest.mark.real_telegram  # Marker per test che inviano messaggi reali
async def test_quick_interactive(configured_telegram_service, mock_notion_service, sample_training_data):
    """
    Test interattivo principale che usa le fixture pytest.
    
    Args:
        configured_telegram_service: TelegramService configurato (fixture)
        mock_notion_service: MockNotionService (fixture)
        sample_training_data: Dati di esempio (fixture)
    """
    try:
        # Crea runner con servizi dalle fixture
        runner = QuickTestRunner(
            telegram_service=configured_telegram_service,
            notion_service=mock_notion_service, 
            sample_data=sample_training_data
        )
        
        # Esegui tutti i test
        await runner.run_all_tests()
        
    except KeyboardInterrupt:
        print("\nâŒ¨ï¸ Test interrotto dall'utente")
    except Exception as e:
        print(f"\nâŒ Errore generale: {e}")
        pytest.fail(f"Test fallito: {e}")


# Entry point per esecuzione diretta (compatibilitÃ )
if __name__ == "__main__":
    print("ğŸ’¡ Per eseguire questo test, usa:")
    print("   pytest tests/quick_real_test.py::test_quick_interactive -s")
    print("   oppure")
    print("   python -m pytest tests/quick_real_test.py::test_quick_interactive -s")